import math

'''
Contains methods to match and create Templates
'''


def Distance(p1, p2):
    p1x, p1y = p1
    p2x, p2y = p2
    dx = p2x - p1x
    dy = p2y - p1y
    return math.sqrt(dx * dx + dy * dy)


def PathLength(points):
    d = 0.0
    for i in range(1, len(points)):
        d += Distance(points[i - 1], points[i])
    return d


def resample(points, n):
    I = PathLength(points) / (n - 1)
    D = 0.0
    newpoints = [points[0]]

    i = 1
    while i < len(points):
        d = Distance(points[i - 1], points[i])
        if D + d >= I:
            x1, y1 = points[i]
            x2, y2 = points[i - 1]
            qx = x2 + ((I - D) / d) * (x1 - x2)
            qy = y2 + ((I - D) / d) * (y1 - y2)
            q = (qx, qy)
            newpoints.append(q)
            points.insert(i, q)
            D = 0.0
        else:
            D += d
        i += 1

    if len(newpoints) == n - 1:
        x, y = points[len(points) - 1]
        newpoints.append((x, y))

    return newpoints


def Centroid(points):
    x = 0.0
    y = 0.0
    for i in range(0, len(points)):
        x1, y1 = points[i]
        x += x1
        y += y1
    x /= len(points)
    y /= len(points)
    return x, y


def IndicativeAngle(points):
    c1, c2 = Centroid(points)
    x, y = points[0]
    return math.atan2(c2 - y, c1 - x)


# generated by chatGPT, asked how to find all points of the line between two Points
def line_points(point1, point2):
    x1, y1 = point1
    x2, y2 = point2

    if x1 == x2:
        min_y = min(y1, y2)
        max_y = max(y1, y2)
        return [(x1, y) for y in range(min_y, max_y + 1)]

    min_x = min(x1, x2)
    max_x = max(x1, x2)

    m = (y2 - y1) / (x2 - x1)

    c = y1 - m * x1

    points = [(x, m * x + c) for x in range(min_x, max_x + 1)]

    return points


def RotateBy(points, radians):
    cx, cy = Centroid(points)
    cos = math.cos(radians)
    sin = math.sin(radians)
    newpoints = []

    for i in range(len(points)):
        x, y = points[i]
        qx = (x - cx) * cos - (y - cy) * sin + cx
        qy = (x - cx) * sin + (y - cy) * cos + cy
        newpoints.append((qx, qy))
    return newpoints


def boundingBox(points):
    minx = +float('inf')
    maxx = -float('inf')
    miny = +float('inf')
    maxy = -float('inf')

    for i in range(0, len(points)):
        x, y = points[i]
        minx = min(minx, x)
        miny = min(miny, y)
        maxx = max(maxx, x)
        maxy = max(maxy, y)

    return minx, miny, maxx - minx, maxy - miny


def ScaleTo(points, size):
    minx, miny, width, height = boundingBox(points)
    newpoints = []
    for i in range(0, len(points)):
        x, y = points[i]
        qx = x * (size[0] / width)
        qy = y * (size[1] / height)
        newpoints.append((qx, qy))
    return newpoints


def TranslateTo(points, pt):
    cx, cy = Centroid(points)
    ptx, pty = pt
    newpoints = []
    for i in range(0, len(points)):
        x, y = points[i]
        qx = x + ptx - cx
        qy = y + pty - cy
        newpoints.append((qx, qy))

    return newpoints


